<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #F0F2F6;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    /* Resizable drawing box (like a textarea). Width follows the Streamlit container. */
    #resizer {
      width: 100%;
      height: 520px;
      resize: vertical;
      overflow: hidden;
      box-sizing: border-box;
      border: 1px solid rgba(0,0,0,0.18);
      border-radius: 14px;
      background: transparent;
      position: relative;
    }
    #c {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none; /* critical for pointer events on touch/stylus */
      user-select: none;
    }
  </style>
</head>
<body>
  <div id="resizer">
    <canvas id="c"></canvas>
  </div>

  <script>
  // Minimal Streamlit bi-directional component plumbing (no React/tooling).
  const RENDER = "streamlit:render";
  const COMPONENT_READY = "streamlit:componentReady";
  const SET_COMPONENT_VALUE = "streamlit:setComponentValue";
  const SET_FRAME_HEIGHT = "streamlit:setFrameHeight";

  function sendMessageToStreamlitClient(type, data) {
    const outData = Object.assign({ isStreamlitMessage: true, type: type }, data);
    window.parent.postMessage(outData, "*");
  }
  function setFrameHeight(height) {
    sendMessageToStreamlitClient(SET_FRAME_HEIGHT, { height: height });
  }
  function sendDataToPython(data) {
    sendMessageToStreamlitClient(SET_COMPONENT_VALUE, { value: data, dataType: "json" });
  }
  function initComponent() {
    sendMessageToStreamlitClient(COMPONENT_READY, { apiVersion: 1 });
  }

  const resizer = document.getElementById("resizer");
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { willReadFrequently: false });

  // args from Streamlit (defaults here)
  let args = {
    canvas_width: 600,
    canvas_height: 520,
    stroke_width: 2,
    stroke_color: "#000000",
    background_color: "#ffffff",
    pen_only: false,
    tool: "pen", // "pen" | "eraser"
    command: null, // "undo" | "clear"
    command_nonce: 0,
    initial_data_url: null,
  };

  let drawing = false;
  let lastX = 0;
  let lastY = 0;
  let isEmpty = true;

  // Undo history: store data URLs after each stroke end
  let history = [];
  let lastCommandNonce = -1;

  function resizeCanvasTo(w, h, preserve=true) {
    // Preserve current bitmap before resizing (optional)
    let snapshot = null;
    if (preserve) {
      try { snapshot = canvas.toDataURL("image/png"); } catch (e) { snapshot = null; }
    }

    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.max(1, Math.floor(w * dpr));
    canvas.height = Math.max(1, Math.floor(h * dpr));
    canvas.style.width = w + "px";
    canvas.style.height = h + "px";

    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // Fill background
    ctx.fillStyle = args.background_color;
    ctx.fillRect(0, 0, w, h);

    if (snapshot) {
      drawImageDataUrl(snapshot).then(() => {
        // best-effort: keep isEmpty as it was
        emitValue();
      });
    } else {
      emitValue();
    }
  }

  function drawImageDataUrl(dataUrl) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        const w = resizer.clientWidth;
        const h = resizer.clientHeight;
        ctx.fillStyle = args.background_color;
        ctx.fillRect(0, 0, w, h);
        ctx.drawImage(img, 0, 0, w, h);
        resolve(true);
      };
      img.onerror = () => resolve(false);
      img.src = dataUrl;
    });
  }

  function snapshotToHistory() {
    try {
      const url = canvas.toDataURL("image/png");
      history.push(url);
      if (history.length > 30) history.shift();
    } catch (e) {}
  }

  function emitValue() {
    try {
      const url = canvas.toDataURL("image/png");
      sendDataToPython({ data_url: url, is_empty: isEmpty });
    } catch (e) {
      sendDataToPython({ data_url: null, is_empty: true });
    }
  }

  function allowedPointer(e) {
    if (args.pen_only) return e.pointerType === "pen";
    return (e.pointerType === "pen" || e.pointerType === "touch" || e.pointerType === "mouse");
  }

  function isHover(e) {
    return (e.pressure === 0 && e.buttons === 0);
  }

  function getXY(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    return { x, y };
  }

  function pointerDown(e) {
    if (!allowedPointer(e)) return;
    if (isHover(e)) return;

    drawing = true;
    const { x, y } = getXY(e);
    lastX = x;
    lastY = y;

    canvas.setPointerCapture(e.pointerId);

    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.lineWidth = args.stroke_width;

    if (args.tool === "eraser") {
      ctx.strokeStyle = args.background_color;
    } else {
      ctx.strokeStyle = args.stroke_color;
    }
  }

  function pointerMove(e) {
    if (!drawing) return;
    if (!allowedPointer(e)) return;
    if (isHover(e)) return;

    const { x, y } = getXY(e);

    ctx.beginPath();
    ctx.moveTo(lastX, lastY);
    ctx.lineTo(x, y);
    ctx.stroke();

    lastX = x;
    lastY = y;

    isEmpty = false;
  }

  function pointerUp(e) {
    if (!drawing) return;
    drawing = false;
    try { canvas.releasePointerCapture(e.pointerId); } catch (e) {}

    snapshotToHistory();
    emitValue();
  }

  canvas.addEventListener("pointerdown", pointerDown);
  canvas.addEventListener("pointermove", pointerMove);
  canvas.addEventListener("pointerup", pointerUp);
  canvas.addEventListener("pointercancel", pointerUp);

  // Keep iframe height in sync with the resizer height
  function syncFrameHeight() {
    // Use offsetHeight (includes borders) so the bottom border is not clipped.
    setFrameHeight(resizer.offsetHeight + 4);
  }

  // Resize observer for both:
  // - sidebar show/hide (iframe width changes)
  // - user dragging the resizer handle (height changes)
  const ro = new ResizeObserver(() => {
    const w = Math.max(1, resizer.clientWidth);
    const h = Math.max(1, resizer.clientHeight);
    resizeCanvasTo(w, h, true);
    syncFrameHeight();
  });
  ro.observe(resizer);

  function applyArgs(newArgs) {
    args = Object.assign(args, newArgs || {});
    // apply background changes immediately (preserve content)
    resizer.style.background = (args.background_color || "#f8f9fa");
    // initial height (only if not resized yet)
    const desiredH = Math.max(200, parseInt(args.canvas_height || args.height || 520, 10));
    if (!resizer.dataset.userResized) {
      resizer.style.height = desiredH + "px";
    }
    // always sync size and height
    const w = Math.max(1, resizer.clientWidth);
    const h = Math.max(1, resizer.clientHeight);
    resizeCanvasTo(w, h, true);
    syncFrameHeight();

    // initial data url (only once, unless explicit)
    if (args.initial_data_url && history.length === 0 && isEmpty) {
      drawImageDataUrl(args.initial_data_url).then((ok) => {
        if (ok) {
          isEmpty = false;
          snapshotToHistory();
          emitValue();
        }
      });
    }

    // commands (undo/clear)
    const cmd = args.command;
    const nonce = args.command_nonce;
    if (nonce !== lastCommandNonce && cmd) {
      lastCommandNonce = nonce;
      if (cmd === "clear") {
        const w2 = resizer.clientWidth;
        const h2 = resizer.clientHeight;
        ctx.fillStyle = args.background_color;
        ctx.fillRect(0, 0, w2, h2);
        isEmpty = true;
        history = [];
        emitValue();
        return;
      }
      if (cmd === "undo") {
        if (history.length === 0) {
          const w2 = resizer.clientWidth;
          const h2 = resizer.clientHeight;
          ctx.fillStyle = args.background_color;
          ctx.fillRect(0, 0, w2, h2);
          isEmpty = true;
          emitValue();
          return;
        }
        // pop current snapshot
        history.pop();
        const prev = history.length ? history[history.length - 1] : null;
        if (!prev) {
          const w2 = resizer.clientWidth;
          const h2 = resizer.clientHeight;
          ctx.fillStyle = args.background_color;
          ctx.fillRect(0, 0, w2, h2);
          isEmpty = true;
          emitValue();
          return;
        }
        drawImageDataUrl(prev).then(() => {
          isEmpty = false;
          emitValue();
        });
      }
    }
  }

  // Mark the resizer as user-resized when they mouseup after drag
  resizer.addEventListener("mouseup", () => { resizer.dataset.userResized = "1"; });
  resizer.addEventListener("touchend", () => { resizer.dataset.userResized = "1"; });

  // Streamlit event listener
  window.addEventListener("message", (event) => {
    const data = event.data;
    if (!data || !data.isStreamlitMessage) return;
    if (data.type === RENDER) {
      applyArgs(data.args || {});
    }
  });

  // Kick off
  initComponent();
  // Set initial frame height
  setTimeout(() => { syncFrameHeight(); }, 0);
  </script>
</body>
</html>
