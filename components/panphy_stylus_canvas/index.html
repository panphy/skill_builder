<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: transparent;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }

    /* Outer container matches app background; canvas itself matches input grey */
    #resizer {
      width: 100%;
      height: 420px;           /* default; JS will set from args.height */
      min-height: 260px;
      resize: vertical;        /* user can drag the bottom edge like a textarea */
      overflow: hidden;
      box-sizing: border-box;
      border-radius: 12px;
      border: 1px solid rgba(128,128,128,0.35);
      background: transparent; /* behind-canvas uses app background */
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;      /* prevents scroll/pinch interfering with drawing */
      background: var(--canvas-bg, #F0F2F6); /* the drawing surface colour */
    }
  </style>
</head>
<body>
  <div id="resizer">
    <canvas id="canvas"></canvas>
  </div>

  <script>
  // Streamlit custom component messaging
  let args = {};
  const resizer = document.getElementById("resizer");
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  // Drawing state
  let tool = "pen";
  let strokeWidth = 2;
  let strokeColor = "#000000";
  let penOnly = false;
  let bgColor = "#F0F2F6";

  let isDrawing = false;
  let lastX = 0, lastY = 0;

  // Undo history as image dataURLs
  const history = [];
  let historyIndex = -1;
  let isEmpty = true;

  function setFrameHeight(h) {
    // Tell Streamlit the height; include a small margin for borders.
    const msg = {isStreamlitMessage: true, type: "streamlit:setFrameHeight", height: h};
    window.parent.postMessage(msg, "*");
  }

  function snapshotToHistory() {
    try {
      const url = canvas.toDataURL("image/png");
      // Truncate redo branch
      if (historyIndex < history.length - 1) history.splice(historyIndex + 1);
      history.push(url);
      historyIndex = history.length - 1;
    } catch (e) {}
  }

  async function drawImageDataUrl(dataUrl) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        ctx.save();
        ctx.globalCompositeOperation = "source-over";
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        ctx.restore();
        resolve(true);
      };
      img.onerror = () => resolve(false);
      img.src = dataUrl;
    });
  }

  function clearToBackground() {
    ctx.save();
    ctx.globalCompositeOperation = "source-over";
    ctx.fillStyle = bgColor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
    isEmpty = true;
    snapshotToHistory();
    sendState();
  }

  function resizeCanvasTo(wCss, hCss, keepContent=true) {
    const dpr = window.devicePixelRatio || 1;
    const w = Math.max(50, Math.floor(wCss));
    const h = Math.max(50, Math.floor(hCss));

    // Preserve content
    let prev = null;
    if (keepContent) {
      try { prev = canvas.toDataURL("image/png"); } catch (e) { prev = null; }
    }

    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = w + "px";
    canvas.style.height = h + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // Paint background
    ctx.save();
    ctx.globalCompositeOperation = "source-over";
    ctx.fillStyle = bgColor;
    ctx.fillRect(0, 0, w, h);
    ctx.restore();

    if (prev) {
      drawImageDataUrl(prev).then(() => sendState());
    } else {
      sendState();
    }
  }

  function fitToResizer(keepContent=true) {
    const r = resizer.getBoundingClientRect();
    // Use inner box; borders are outside the rect
    resizeCanvasTo(r.width, r.height, keepContent);
    // Include borders and a tiny margin so the bottom line is visible
    setFrameHeight(resizer.offsetHeight + 6);
  }

  // Resize observer to handle sidebar toggle + user drag-resize
  const ro = new ResizeObserver(() => fitToResizer(true));
  ro.observe(resizer);

  function getPointerType(ev) {
    return ev.pointerType || (ev.touches ? "touch" : "mouse");
  }

  function allowedPointer(ev) {
    if (!penOnly) return true;
    const pt = getPointerType(ev);
    return pt === "pen";
  }

  function getPos(ev) {
    const rect = canvas.getBoundingClientRect();
    const x = (ev.clientX - rect.left);
    const y = (ev.clientY - rect.top);
    return {x, y};
  }

  function beginStroke(x, y) {
    isDrawing = true;
    lastX = x; lastY = y;
    ctx.save();
    if (tool === "eraser") {
      ctx.globalCompositeOperation = "destination-out";
      ctx.strokeStyle = "rgba(0,0,0,1)";
      ctx.lineWidth = strokeWidth * 6;
    } else {
      ctx.globalCompositeOperation = "source-over";
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = strokeWidth;
    }
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.restore();
  }

  function continueStroke(x, y) {
    if (!isDrawing) return;
    ctx.save();
    if (tool === "eraser") {
      ctx.globalCompositeOperation = "destination-out";
      ctx.strokeStyle = "rgba(0,0,0,1)";
      ctx.lineWidth = strokeWidth * 6;
    } else {
      ctx.globalCompositeOperation = "source-over";
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = strokeWidth;
    }
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.beginPath();
    ctx.moveTo(lastX, lastY);
    ctx.lineTo(x, y);
    ctx.stroke();
    ctx.restore();
    lastX = x; lastY = y;
    isEmpty = false;
  }

  function endStroke() {
    if (!isDrawing) return;
    isDrawing = false;
    snapshotToHistory();
    sendState();
  }

  canvas.addEventListener("pointerdown", (ev) => {
    if (!allowedPointer(ev)) return;
    ev.preventDefault();
    canvas.setPointerCapture(ev.pointerId);
    const {x, y} = getPos(ev);
    beginStroke(x, y);
  });

  canvas.addEventListener("pointermove", (ev) => {
    if (!allowedPointer(ev)) return;
    if (!isDrawing) return;
    ev.preventDefault();
    const {x, y} = getPos(ev);
    continueStroke(x, y);
  });

  canvas.addEventListener("pointerup", (ev) => {
    if (!allowedPointer(ev)) return;
    ev.preventDefault();
    endStroke();
  });
  canvas.addEventListener("pointercancel", (ev) => { endStroke(); });

  function undo() {
    if (historyIndex <= 0) return;
    historyIndex -= 1;
    const url = history[historyIndex];
    // Clear then draw
    ctx.save();
    ctx.globalCompositeOperation = "source-over";
    ctx.fillStyle = bgColor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
    drawImageDataUrl(url).then(() => sendState());
  }

  function sendState() {
    let data_url = null;
    try { data_url = canvas.toDataURL("image/png"); } catch (e) {}
    const msg = {isStreamlitMessage: true, type: "streamlit:setComponentValue", value: {data_url, is_empty: isEmpty}};
    window.parent.postMessage(msg, "*");
  }

  async function applyArgs(a) {
    args = a || {};
    tool = (args.tool === "eraser") ? "eraser" : "pen";
    strokeWidth = Number(args.stroke_width) || 2;
    strokeColor = String(args.stroke_color || "#000000");
    penOnly = !!args.pen_only;
    bgColor = String(args.background_color || "#F0F2F6");

    // Apply background to canvas
    document.documentElement.style.setProperty("--canvas-bg", bgColor);

    // Set initial height
    const h = Number(args.height) || 420;
    resizer.style.height = h + "px";

    // Fit now
    fitToResizer(false);

    // Initial restore
    if (args.initial_data_url && typeof args.initial_data_url === "string") {
      const ok = await drawImageDataUrl(args.initial_data_url);
      if (ok) {
        isEmpty = false;
        snapshotToHistory();
        sendState();
      }
    } else {
      // Ensure history starts with a clean background
      snapshotToHistory();
      sendState();
    }

    // Commands
    if (args.command === "undo") undo();
    if (args.command === "clear") clearToBackground();
  }

  function onDataFromPython(event) {
    const data = event.data;
    if (!data || !data.isStreamlitMessage) return;
    if (data.type === "streamlit:render") {
      applyArgs(data.args || {});
    }
  }

  window.addEventListener("message", onDataFromPython);

  // Initialize
  window.addEventListener("load", () => {
    // Default paint
    document.documentElement.style.setProperty("--canvas-bg", "#F0F2F6");
    fitToResizer(false);
    snapshotToHistory();
    sendState();
  });
  </script>
</body>
</html>
