<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: transparent;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }

    #outer {
      width: 100%;
      padding: 0;
      box-sizing: border-box;
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }

    /* Resizable container (vertical) to mimic textarea resize UX */
    #resizable {
      width: 100%;
      height: 420px; /* overwritten by args + persisted height */
      resize: vertical;
      overflow: hidden;
      box-sizing: border-box;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,0.08);
      background: #ffffff;
      position: relative;
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }

    /* Disable resize handle when not allowed */
    #resizable.no-resize {
      resize: none;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none; /* important for stylus/touch drawing */
      background: #ffffff;
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }
  </style>
</head>
<body>
  <div id="outer">
    <div id="resizable">
      <canvas id="c"></canvas>
    </div>
  </div>

  <script>
  // Minimal Streamlit bi-directional component plumbing (no React/tooling).
  const RENDER = "streamlit:render";
  const COMPONENT_READY = "streamlit:componentReady";
  const SET_COMPONENT_VALUE = "streamlit:setComponentValue";
  const SET_FRAME_HEIGHT = "streamlit:setFrameHeight";

  function sendMessageToStreamlitClient(type, data) {
    const outData = Object.assign({ isStreamlitMessage: true, type: type }, data);
    window.parent.postMessage(outData, "*");
  }
  function setFrameHeight(height) {
    sendMessageToStreamlitClient(SET_FRAME_HEIGHT, { height: height });
  }
  function sendDataToPython(data) {
    sendMessageToStreamlitClient(SET_COMPONENT_VALUE, { value: data, dataType: "json" });
  }
  function initComponent() {
    sendMessageToStreamlitClient(COMPONENT_READY, { apiVersion: 1 });
  }

  const resizable = document.getElementById("resizable");
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  let args = {
    height: 420,
    width: null,
    stroke_width: 2,
    stroke_color: "#000000",
    background_color: "#ffffff",
    pen_only: false,
    tool: "pen",
    command: null,
    command_nonce: 0,
    initial_data_url: null,
    resizable: true,
    min_height: 220,
    max_height: 1200,
    storage_key: null,
  };

  let drawing = false;
  let lastX = 0;
  let lastY = 0;
  let isEmpty = true;

  // Undo history: store data URLs after each stroke end
  let history = [];
  let lastCommandNonce = -1;
  let lastArgsHeight = null;

  // Current logical size in CSS pixels
  let currentW = 0;
  let currentH = 0;

  function clamp(n, lo, hi) {
    return Math.max(lo, Math.min(hi, n));
  }

  function getStorageKey() {
    const k = args.storage_key;
    if (typeof k === "string" && k.trim()) return k.trim();
    return null;
  }

  function tryLoadPersistedHeight() {
    const k = getStorageKey();
    if (!k) return null;
    try {
      const raw = window.localStorage.getItem(k);
      const v = Number(raw);
      if (Number.isFinite(v) && v > 0) return v;
    } catch (e) {}
    return null;
  }

  function tryPersistHeight(h) {
    const k = getStorageKey();
    if (!k) return;
    try { window.localStorage.setItem(k, String(Math.round(h))); } catch (e) {}
  }

  function clearCanvas() {
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = args.background_color || "#ffffff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
  }

  async function drawImageDataUrl(dataUrl) {
    if (!dataUrl) return false;
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        // Draw at 1:1 device pixels to avoid DPR scaling.
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.drawImage(img, 0, 0);
        ctx.restore();
        resolve(true);
      };
      img.onerror = () => resolve(false);
      img.src = dataUrl;
    });
  }

  function snapshotToHistory() {
    const url = canvas.toDataURL("image/png");
    history.push(url);
    if (history.length > 30) history.shift();
  }

  function emitValue() {
    const url = canvas.toDataURL("image/png");
    sendDataToPython({ data_url: url, is_empty: !!isEmpty });
  }

  function setCanvasSize(w, h, preserve) {
    w = Math.max(1, Math.floor(w));
    h = Math.max(1, Math.floor(h));

    // Preserve current pixels if requested
    let prevUrl = null;
    if (preserve && currentW > 0 && currentH > 0 && !isEmpty) {
      try { prevUrl = canvas.toDataURL("image/png"); } catch (e) { prevUrl = null; }
    }

    const dpr = window.devicePixelRatio || 1;

    canvas.style.width = w + "px";
    canvas.style.height = h + "px";
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    currentW = w;
    currentH = h;

    // Always re-fill background on resize
    clearCanvas();

    if (prevUrl) {
      // Restore pixels into the new canvas (top-left)
      drawImageDataUrl(prevUrl).then((ok) => {
        if (ok) {
          isEmpty = false;
          // Do NOT snapshot on resize (keeps undo intuitive)
          emitValue();
        }
      });
    } else {
      // If we had no prior drawing, stay empty
      isEmpty = true;
      history = [];
      emitValue();
    }
  }

  function resizeToContainer(preserve) {
    const rect = resizable.getBoundingClientRect();
    const w = Math.max(1, Math.floor(rect.width));
    const h = Math.max(1, Math.floor(rect.height));
    if (w !== currentW || h !== currentH) {
      setCanvasSize(w, h, preserve);
    }
  }

  function getXY(evt) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: (evt.clientX - rect.left),
      y: (evt.clientY - rect.top),
    };
  }

  function pointerDown(evt) {
    if (args.pen_only && evt.pointerType !== "pen") return;
    evt.preventDefault();
    drawing = true;
    canvas.setPointerCapture(evt.pointerId);
    const p = getXY(evt);
    lastX = p.x;
    lastY = p.y;

    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.lineWidth = Number(args.stroke_width) || 2;

    if ((args.tool || "pen") === "eraser") {
      // Erase by drawing with background color
      ctx.strokeStyle = args.background_color || "#ffffff";
    } else {
      ctx.strokeStyle = args.stroke_color || "#000000";
    }
  }

  function pointerMove(evt) {
    if (!drawing) return;
    if (args.pen_only && evt.pointerType !== "pen") return;
    evt.preventDefault();

    const p = getXY(evt);
    ctx.beginPath();
    ctx.moveTo(lastX, lastY);
    ctx.lineTo(p.x, p.y);
    ctx.stroke();
    lastX = p.x;
    lastY = p.y;
    isEmpty = false;
  }

  function pointerUp(evt) {
    if (!drawing) return;
    drawing = false;
    try { canvas.releasePointerCapture(evt.pointerId); } catch (e) {}
    snapshotToHistory();
    emitValue();
  }

  canvas.addEventListener("pointerdown", pointerDown);
  canvas.addEventListener("pointermove", pointerMove);
  canvas.addEventListener("pointerup", pointerUp);
  canvas.addEventListener("pointercancel", pointerUp);
  canvas.addEventListener("contextmenu", (evt) => evt.preventDefault());

  async function applyCommand(cmd) {
    if (!cmd) return;

    if (cmd === "clear") {
      clearCanvas();
      isEmpty = true;
      history = [];
      emitValue();
      return;
    }

    if (cmd === "undo") {
      if (!history.length) {
        clearCanvas();
        isEmpty = true;
        emitValue();
        return;
      }
      history.pop(); // remove latest
      const prev = history.length ? history[history.length - 1] : null;
      if (!prev) {
        clearCanvas();
        isEmpty = true;
        emitValue();
        return;
      }
      clearCanvas();
      const ok = await drawImageDataUrl(prev);
      isEmpty = !ok;
      emitValue();
      return;
    }
  }

  // Observe container resize (sidebar toggle, user drag-resize handle, responsive width changes)
  const ro = new ResizeObserver((entries) => {
    for (const entry of entries) {
      const cr = entry.contentRect;
      const newH = clamp(cr.height, Number(args.min_height) || 220, Number(args.max_height) || 1200);
      if (Math.abs(cr.height - newH) > 1) {
        // enforce bounds
        resizable.style.height = newH + "px";
      }
      resizeToContainer(true);
      setFrameHeight(Math.ceil(resizable.getBoundingClientRect().height) + 6);
      tryPersistHeight(resizable.getBoundingClientRect().height);
    }
  });
  ro.observe(resizable);

  async function onDataFromPython(event) {
    if (event.data.type !== RENDER) return;
    const a = event.data.args || {};

    // Update args (with defaults)
    args.height = a.height ?? args.height;
    args.width = a.width ?? args.width;
    args.stroke_width = a.stroke_width ?? args.stroke_width;
    args.stroke_color = a.stroke_color ?? args.stroke_color;
    args.background_color = a.background_color ?? args.background_color;
    args.pen_only = a.pen_only ?? args.pen_only;
    args.tool = a.tool ?? args.tool;
    args.resizable = a.resizable ?? args.resizable;
    args.min_height = a.min_height ?? args.min_height;
    args.max_height = a.max_height ?? args.max_height;
    args.storage_key = a.storage_key ?? args.storage_key;

    // Apply resizable setting
    if (args.resizable) resizable.classList.remove("no-resize");
    else resizable.classList.add("no-resize");

    // Set initial height (prefer persisted user choice) or apply when args.height changes
    const persisted = tryLoadPersistedHeight();
    const baseH = Number(args.height) || 420;
    const h = clamp(persisted ?? baseH, Number(args.min_height) || 220, Number(args.max_height) || 1200);
    if (!currentH || Number(args.height) !== lastArgsHeight) {
      resizable.style.height = h + "px";
      lastArgsHeight = Number(args.height);
      tryPersistHeight(h);
    }

    // Ensure we are sized correctly (preserve drawing if resizing)
    resizeToContainer(true);

    // Initial restore (optional): only restore if currently blank
    if (a.initial_data_url && typeof a.initial_data_url === "string") {
      if (isEmpty) {
        const ok = await drawImageDataUrl(a.initial_data_url);
        if (ok) {
          isEmpty = false;
          snapshotToHistory();
          emitValue();
        }
      }
    }

    // Commands are gated by command_nonce so they don't repeat on reruns
    const nonce = Number(a.command_nonce ?? 0);
    if (nonce !== lastCommandNonce) {
      lastCommandNonce = nonce;
      const cmd = a.command ?? null;
      await applyCommand(cmd);
    }

    setFrameHeight(Math.ceil(resizable.getBoundingClientRect().height) + 6);
  }

  window.addEventListener("message", onDataFromPython);

  // Initialize
  initComponent();

  window.addEventListener("load", () => {
    // Give Streamlit a sane initial height right away
    setTimeout(() => setFrameHeight((args.height || 420) + 6), 0);
  });
  </script>
</body>
</html>
