<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>

    html, body { margin:0; padding:0; background: transparent; }
    #resizer{
      width: 100%;
      min-height: 260px;
      height: 420px;
      resize: vertical;
      overflow: auto;
      box-sizing: border-box;
      background: transparent;
      border-radius: 14px;
      border: 1px solid rgba(49, 51, 63, 0.2);
    }
    canvas#c{
      display:block;
      width: 100%;
      height: 100%;
      background: var(--canvas-bg, #F0F2F6);
      border-radius: 14px;
    }


    html, body {
      margin: 0;
      padding: 0;
      background: transparent;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    #wrap {
      width: 100%;
      height: auto;
      box-sizing: border-box;
      border-radius: 12px;
      overflow: visible;
      background: #ffffff;
      border: 1px solid rgba(128,128,128,0.35);
    }
    canvas {
      touch-action: none; /* prevents scrolling while drawing */
      display: block;
      width: 100%;
      height: 100%;
      border-radius: 0;
      box-sizing: border-box;
      border: 0;
    }

  </style>
</head>
<body>
  <div id="wrap">
    <div id="resizer"><canvas id="c"></canvas></div>
  </div>

  <script>
  // Minimal Streamlit bi-directional component plumbing (no React/tooling).
  // Based on Streamlit community snippet (tvst) + variations:
  // - streamlit:componentReady
  // - streamlit:setFrameHeight
  // - streamlit:setComponentValue
  const RENDER = "streamlit:render";
  const COMPONENT_READY = "streamlit:componentReady";
  const SET_COMPONENT_VALUE = "streamlit:setComponentValue";
  const SET_FRAME_HEIGHT = "streamlit:setFrameHeight";

  function sendMessageToStreamlitClient(type, data) {
    const outData = Object.assign({ isStreamlitMessage: true, type: type }, data);
    window.parent.postMessage(outData, "*");
  }
  function setFrameHeight(height) {
    sendMessageToStreamlitClient(SET_FRAME_HEIGHT, { height: height });
  }
  function sendDataToPython(data) {
    sendMessageToStreamlitClient(SET_COMPONENT_VALUE, { value: data, dataType: "json" });
  }
  function initComponent() {
    sendMessageToStreamlitClient(COMPONENT_READY, { apiVersion: 1 });
  }

  const resizer = document.getElementById("resizer");
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { willReadFrequently: false });

  let args = {
    width: 600,
    height: 400,
    stroke_width: 2,
    stroke_color: "#000000",
    background_color: "#ffffff",
    pen_only: false,
    tool: "pen",
    command: null,
    command_nonce: 0,
    initial_data_url: null,
  };


  let lastCssW = args.width;
  let lastCssH = args.height;

  let drawing = false;
  let lastX = 0;
  let lastY = 0;
  let isEmpty = true;

  // Undo history: store data URLs after each stroke end
  let history = [];
  let lastCommandNonce = -1;

  function resizePreserve(w, h) {
    const prevW = lastCssW;
    const prevH = lastCssH;

    let snapshot = null;
    if (!isEmpty) {
      try {
        snapshot = canvas.toDataURL("image/png");
      } catch (e) {
        snapshot = null;
      }
    }

    lastCssW = w;
    lastCssH = h;
    args.width = w;
    args.height = h;

    // handle device pixel ratio for sharpness
    const dpr = window.devicePixelRatio || 1;
    canvas.style.width = w + "px";
    canvas.style.height = h + "px";
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // fill background
    canvas.style.setProperty('--canvas-bg', args.background_color || '#F0F2F6');
    ctx.fillStyle = args.background_color || '#F0F2F6';
    ctx.fillRect(0, 0, w, h);

    // Reset undo/redo history on resize to avoid coordinate mismatches
    history = [];

    if (snapshot) {
      // Redraw at the ORIGINAL scale (no fit-to-canvas). This prevents drawings from "rescaling" when layout changes.
      return drawImageDataUrl(snapshot, prevW, prevH, { pushHistory: false }).then(() => true);
    }

    isEmpty = true;
    return Promise.resolve(false);
  }

  // Backwards-compatible name
  function resizeAndReset(w, h) {
    return resizePreserve(w, h);
  }


function drawImageDataUrl(dataUrl, drawW, drawH, opts) {
    const w = (typeof drawW === "number" && drawW > 0) ? drawW : args.width;
    const h = (typeof drawH === "number" && drawH > 0) ? drawH : args.height;
    const pushHistory = !(opts && opts.pushHistory === false);

    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        // Fill background at current canvas size
        canvas.style.setProperty('--canvas-bg', args.background_color || '#F0F2F6');
        ctx.fillStyle = args.background_color || '#F0F2F6';
        ctx.fillRect(0, 0, lastCssW, lastCssH);

        // Draw WITHOUT fitting to the new canvas size. Use the provided drawW/drawH (usually the original snapshot size).
        ctx.drawImage(img, 0, 0, w, h);

        isEmpty = false;
        if (pushHistory) snapshotToHistory();
        resolve(true);
      };
      img.onerror = () => resolve(false);
      img.src = dataUrl;
    });
  }

  function snapshotToHistory() {
    // Keep at most 30 snapshots to bound memory
    const url = canvas.toDataURL("image/png");
    history.push(url);
    if (history.length > 30) history.shift();
  }

  function emitValue() {
    const url = canvas.toDataURL("image/png");
    sendDataToPython({ data_url: url, is_empty: isEmpty, draw_width: lastCssW, draw_height: lastCssH });
  }

  function allowedPointer(e) {
    if (args.pen_only) return e.pointerType === "pen";
    return (e.pointerType === "pen" || e.pointerType === "touch" || e.pointerType === "mouse");
  }

  function isHover(e) {
    // On devices that support hover (incl. some stylus), pressure==0 and buttons==0 indicates hover.
    // Also guard against move events without contact.
    return (e.pressure === 0 && e.buttons === 0);
  }

  function pointerDown(e) {
    if (!allowedPointer(e)) return;
    if (isHover(e)) return;

    drawing = true;
    const rect = canvas.getBoundingClientRect();
    lastX = e.clientX - rect.left;
    lastY = e.clientY - rect.top;

    // Capture pointer so we keep receiving move/up
    try { canvas.setPointerCapture(e.pointerId); } catch (_) {}
  }

  function pointerMove(e) {
    if (!drawing) return;
    if (!allowedPointer(e)) return;
    if (isHover(e)) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.lineWidth = args.stroke_width;

    if (args.tool === "eraser") {
      ctx.strokeStyle = args.background_color;
    } else {
      ctx.strokeStyle = args.stroke_color;
    }

    ctx.beginPath();
    ctx.moveTo(lastX, lastY);
    ctx.lineTo(x, y);
    ctx.stroke();

    lastX = x;
    lastY = y;

    isEmpty = false;
  }

  function pointerUp(e) {
    if (!drawing) return;
    drawing = false;

    // Save snapshot for undo and emit value (only after stroke end)
    snapshotToHistory();
    emitValue();
  }

  canvas.addEventListener("pointerdown", pointerDown);
  canvas.addEventListener("pointermove", pointerMove);
  canvas.addEventListener("pointerup", pointerUp);
  canvas.addEventListener("pointercancel", pointerUp);
  canvas.addEventListener("pointerleave", (e) => { /* do nothing */ });

  async function applyCommand(cmd) {
    if (!cmd) return;
    if (cmd === "clear") {
      canvas.style.setProperty('--canvas-bg', args.background_color || '#F0F2F6');
    ctx.fillStyle = args.background_color || '#F0F2F6';
      ctx.fillRect(0, 0, lastCssW, lastCssH);
      isEmpty = true;
      history = [];
      emitValue();
      return;
    }
    if (cmd === "undo") {
      // Undo: pop current snapshot, then restore previous
      if (history.length === 0) {
        // nothing to undo
        canvas.style.setProperty('--canvas-bg', args.background_color || '#F0F2F6');
    ctx.fillStyle = args.background_color || '#F0F2F6';
        ctx.fillRect(0, 0, lastCssW, lastCssH);
        isEmpty = true;
        emitValue();
        return;
      }
      history.pop(); // remove latest
      const prev = history.length ? history[history.length - 1] : null;
      if (!prev) {
        canvas.style.setProperty('--canvas-bg', args.background_color || '#F0F2F6');
    ctx.fillStyle = args.background_color || '#F0F2F6';
        ctx.fillRect(0, 0, lastCssW, lastCssH);
        isEmpty = true;
        emitValue();
        return;
      }
      const ok = await drawImageDataUrl(prev);
      isEmpty = !ok ? true : false;
      emitValue();
      return;
    }
  }

  async function onDataFromPython(event) {
    if (event.data.type !== RENDER) return;
    const a = event.data.args || {};

    // Update args (with defaults)
    args.width = a.width ?? args.width;
    args.height = a.height ?? args.height;
    args.stroke_width = a.stroke_width ?? args.stroke_width;
    args.stroke_color = a.stroke_color ?? args.stroke_color;
    args.background_color = a.background_color ?? args.background_color;
    args.pen_only = a.pen_only ?? args.pen_only;
    args.tool = a.tool ?? args.tool;

    // Resize only if needed (keeps drawing stable)
    const w = (resizer ? resizer.clientWidth : Number(args.width)) || 600;
    const h = (resizer ? resizer.clientHeight : Number(args.height)) || 400;

    const needResize = (canvas.style.width !== (w + "px")) || (canvas.style.height !== (h + "px"));
    if (needResize) {
      await resizeAndReset(w, h);
    }

    // Initial restore (optional)
    if (a.initial_data_url && typeof a.initial_data_url === "string") {
      // only restore if blank
      if (isEmpty) {
        const ok = await drawImageDataUrl(
          a.initial_data_url,
          a.initial_draw_width || a.width,
          a.initial_draw_height || a.height,
          { pushHistory: true }
        );
        if (ok) {
          isEmpty = false;
          snapshotToHistory();
          emitValue();
        }
      }
    }

    // Commands are gated by command_nonce so they don't repeat on reruns
    const nonce = Number(a.command_nonce ?? 0);
    if (nonce !== lastCommandNonce) {
      lastCommandNonce = nonce;
      const cmd = a.command ?? null;
      await applyCommand(cmd);
    }

    // adjust frame height
    setFrameHeight(h + 6);
  }

  window.addEventListener("message", onDataFromPython);

  // Initialize
  initComponent();

  // In case Streamlit doesn't immediately size the iframe
  window.addEventListener("load", () => {
    setTimeout(() => setFrameHeight((args.height || 400) + 6), 0);
  });

  if (window.ResizeObserver && resizer) {
    const resizeObserver = new ResizeObserver(() => {
      const w = resizer.clientWidth || args.width || 600;
      const h = resizer.clientHeight || args.height || 400;
      if (w > 0 && h > 0) {
        resizeAndReset(w, h);
        setFrameHeight(h + 6);
      }
    });
    resizeObserver.observe(resizer);
  }

  window.addEventListener("resize", () => {
    if (!resizer) return;
    const w = resizer.clientWidth || args.width || 600;
    const h = resizer.clientHeight || args.height || 400;
    if (w > 0 && h > 0) {
      resizeAndReset(w, h);
      setFrameHeight(h + 6);
    }
  });
  </script>
</body>
</html>
